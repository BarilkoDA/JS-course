'use strict';

//Для получения элементов со страницы мы можем воспрользоваться различными командами.

const boxQuery = document.querySelectorAll('.box');
const boxesGet = document.getElementsByClassName('box');

// Данные псевдомассивы сформированы структурно по разному и имеют разный функционал
// Структура которая формируется через querySelectorAll полезнее посколько у нее есть методы которые позволяют работать с элементами.

console.log(boxQuery);
console.log(boxesGet );

// Такое явление называется живые и статические коллекции

//Пример: Происходи 2 операции по удалению из псевдомассивов

boxQuery[0].remove();
boxesGet[0].remove();

// Команды работают с DOM элементами. Не важно где располагаются элементы они будут удалены из верстки
// Поэтому по факту в верстке остался один элемент.

console.log(boxQuery); // 3 элемента
/* 
В boxQuery мы получили состояние элементов на момент вызова querySelectorAll
Это как отпечаток, слепое того, что происходило тогда но эта коллекция она статична.
 */

console.log(boxesGet); // один элемент (живая коллекция) 

/* 
boxesGet как и вариант с children наоборот отслеживает все изменения в DOM дереве и возвращает псевдомассив с актуальными данными.
Структура HTMLCollection отслеживает текущие изменения.
 */

/*
Использование:

В современном мире почти для всех задач подходит querySelectorAll и можно ограничиваться не живыми (статичными коллекциями)

Если же в рамках задачи требуется отследивать состояние DOM дерева используются живые коллекции но нужно помнить что у них отсутствуют методы для работы с ними.
И манипулировать как с обычными массивами не получиться. 

Для этого существуют различные техники. Одна из них это создание массива из масиво-подобного объекта
*/

console.log(Array.from(boxesGet)); // прием можно применять тогда когда требуется отследить изменения DOM дерева на конкретный момент времени.

// В псевдомассив не возможно добавить элемент. Это запрещено синтаксисом JS

for (let i = 0; i < 5; i++) {
    const div = document.createElement('div');
    div.classList.add('box');
    document.body.add(div); // правильно
    boxesGet[boxesGet.length] = div; // Не правильно - ошибка
}

/* 
2 метода: Для поиска конкретного элемента по определенным параметрам 
к примеру css селектору

1) matches используется на одном конкретном элементе. Поиск внутри элемента на котором он применяется и возвращал true или false.
*/
boxQuery.forEach(box => {
    if (box.matches('.this')) console.log("This one!");
});

/*
2) closest позволяет по всей цепочке родителей(вверх) найти элемент с определенным селектором.

*/

console.log(boxQuery[0].closest('.wrapper'));



